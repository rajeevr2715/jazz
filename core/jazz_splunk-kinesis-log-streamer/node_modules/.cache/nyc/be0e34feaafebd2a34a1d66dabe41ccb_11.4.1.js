/**
	Custom Splunk cloudWatch logs streamer.
	@Author:
	@version: 1.0
**/

'use strict';

const SplunkLogger = require('splunk-logging').Logger;
const zlib = require('zlib');
const configData = require("./components/config.js"); //Import the environment data.
const logger = require("./components/logger.js"); //Import the logging module.
const errorHandlerModule = require("./components/error-handler.js");
const responseObj = require("./components/response.js");
const utils = require("./components/utils.js"); //Import the utils module.


process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

function handler(event, context, callback){

  logger.debug('Received event:' + JSON.stringify(event));
  let errorHandler = errorHandlerModule();
  let config = configData.getConfig(event, context);

  const loggerConfig = {
    url: config.SPLUNK_ENDPOINT,
    token: config.SPLUNK_TOKEN,
    maxBatchCount: 0, // Manually flush events
    maxRetries: 1 // Retry 1 times
  };

  const splunkLog = new SplunkLogger(loggerConfig);
  // Set common error handler for splunkLog.send() and splunkLog.flush()
  splunkLog.error = (error, payload) => {
    logger.error('error:' + error + ', context:' + JSON.stringify(payload));
    return callback(JSON.stringify(error));
  };

  try {
    // CloudWatch Logs data is base64 encoded so decode here
    const payload = new Buffer(event.awslogs.data, 'base64');

    // CloudWatch Logs are gzip compressed so expand here
    zlib.gunzip(payload, (error, result) => {
      if (error) {
        logger.error(error);
        return callback(JSON.stringify(errorHandler.throwInputValidationError("Not a valid Input")));
      } else {
        // parse the result from JSON
        let awslogsData = JSON.parse(result.toString('ascii'));
        logger.info('Decoded payload:' + JSON.stringify(awslogsData));
        exportable.sendSplunkEvent(awslogsData, splunkLog, config)
          .then((count) => {
            splunkLog.flush((err, resp, body) => {
              // Request failure or valid response from Splunk with HEC error code
              if (err || (body && body.code !== 0)) {
                logger.error("Splunk error:" + JSON.stringify(err));
                // If failed, error will be handled by pre-configured logger.error() below
              } else {
                // If succeeded, body will be { text: 'Success', code: 0 }
                logger.info('Response from Splunk:' + JSON.stringify(body));
                logger.info(`Successfully processed ${count} log event(s).`);
                return callback(null, count); // Return number of log events
              }
            });
          })
          .catch(error => {
            logger.error(JSON.stringify(error));
            if (error.result === 'inputError') {
              return callback(JSON.stringify(errorHandler.throwInputValidationError(error.message)));
            } else {
              return callback(JSON.stringify(errorHandler.throwInternalServerError('Unexpected error occured.')));
            }
          });
      }
    });
  } catch (e) {
    logger.error("Error:" + JSON.stringify(e));
    return callback(JSON.stringify(errorHandler.throwInternalServerError('Unexpected error occured.')));
  }
};

function sendSplunkEvent(awslogsData, splunkLog, config) {
  return new Promise((resolve, reject) => {
    let count = 0;
    if (awslogsData.messageType === 'CONTROL_MESSAGE') {
      logger.debug('Received CONTROL MESSAGE.');
      resolve("Success");
    } else if (awslogsData.logGroup.indexOf("API-Gateway-Execution-Logs") === 0) {
      utils.transformApiLogs(awslogsData)
        .then(splunkBulkData => {
          exportable.sendDataToSplunk(splunkLog, splunkBulkData, config);
          count++;
          resolve(count);
        })
        .catch(error => {
          logger.error(error);
          reject(error);
        });
    } else if (awslogsData.logGroup.indexOf("/aws/lambda/") === 0) {
      let commonData = utils.getCommonData(awslogsData);
      awslogsData.logEvents.forEach(logEvent => {
        utils.transformLambdaLogs(logEvent, commonData)
          .then(event => {
            exportable.sendDataToSplunk(splunkLog, event, config);
            count++;
            if (count === awslogsData.logEvents.length) {
              resolve(count);
            }
          })
          .catch(error => {
            logger.error("Error in sendSplunkEvent:" + JSON.stringify(error));
            reject(error);
          });
      });
    } else {
      logger.error('Received unsupported logEvents');
      reject({
        result: "inputError",
        message: "Received unsupported logEvents"
      });
    }
  });
}

function sendDataToSplunk(splunkLog, eventData, config) {
  logger.debug("Send event data:" + JSON.stringify(eventData));
  let payload = {
    message: "Jazz logs",
    metadata: {
      source: "lambda:jazz_splunk-cw-log-streamer",
      sourcetype: eventData.sourcetype,
      index: config.SPLUNK_INDEX,
      event: eventData.event
    }
  };
  splunkLog.send(payload);
}}

const exportable = {
  handler,
  sendSplunkEvent,
  sendDataToSplunk
}
module.exports = exportable;